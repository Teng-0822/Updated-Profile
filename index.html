<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Profile Manager</title>
  <style>
     button, input, label {
      touch-action: manipulation;
    }   
    html, body {
      margin: 0;
      padding: 12px;
      font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f1923; /* Valorant dark background */
      color: #ece8e1;      /* Light beige text */
      touch-action: manipulation;
    }

    /* Buttons */
    button {
      padding: 10px 16px;
      font-size: 12px;
      font-weight: bold;
      border: 2px solid #ff4655;  /* Valorant red */
      border-radius: 4px;
      background: #1f2329;
      color: #ece8e1;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      flex: 1 1 40%;
      margin: 5px;
      transition: 0.2s ease-in-out;
    }
    button:hover {
      background: #ff4655;
      color: #0f1923;
      box-shadow: 0 0 12px #ff4655;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Profile Box */
    #profileBox {
      background: #1b1f26;
      border: 2px solid #ff4655;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(255,70,85,0.3);
      padding: 16px;
      margin-bottom: 16px;
      color: black;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.75);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal-content {
      background: #0f1923;
      color: #ece8e1;
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #ff4655;
      max-height: 80vh;
      overflow-y: auto;
      width: 95%;
      position: relative;
    }
    .modal-content h3 {
      color: #ff4655;
      text-transform: uppercase;
    }
    .modal-content button {
      background: #ff4655;
      color: #0f1923;
      border: none;
      font-size: 14px;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
    }
    table th, table td {
      border: 1px solid #444;
      padding: 8px;
      font-size: 14px;
    }
    table th {
      background: #1f2329;
      color: #ff4655;
      text-transform: uppercase;
    }
    table tr:nth-child(even) {
      background: #161a1f;
    }

    /* Toast */
    #toast {
      visibility: hidden;
      min-width: 220px;
      background: #ff4655;
      color: #0f1923;
      font-weight: bold;
      text-align: center;
      border-radius: 6px;
      padding: 12px;
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
    }
    #toast.show {
      visibility: visible;
      animation: fadein 0.3s, fadeout 0.5s 2s;
    }
    @keyframes fadein {
      from { bottom: 20px; opacity: 0; }
      to { bottom: 30px; opacity: 1; }
    }
    @keyframes fadeout {
      from { bottom: 30px; opacity: 1; }
      to { bottom: 20px; opacity: 0; }
    }

/* your existing styles + a tiny addition for the IP bar */
   #ipBar {
  background: #2d2d2d;
  border: 2px solid #666;
  border-radius: 8px;
  padding: 10px;
  margin: 12px 0;
  text-align: center;
  font-size: 12px;
  font-weight: bold;
  color: white;
  transition: all 0.4s ease;
}

#ipBar.loading {
  background: #2d2d2d;
  border-color: #666;
  color: #aaa;
}

#ipBar.success {
  background: #008000; /* darker green for better contrast */
  border-color: #00c000;
  color: white;
}

#ipBar.error {
  background: #4f2d2d;
  border-color: #f00;
  color: #ffaaaa;
}
    #rotateIpBtn:disabled { opacity: 0.6; }
  </style>
</head>
<body>
   <div id="buttonContainer" style="display:flex; flex-wrap:wrap; gap:4px; justify-content:center; margin-bottom:10px;">
    <button onclick="prevProfile()">‚¨ÖÔ∏è Prev</button>
    <button onclick="runNextContainer(); nextProfile()">Next ‚û°Ô∏è</button>
    <button onclick="GotoFirst(); goToFirstProfile()">üîÅ First </button>
    <button onclick="preloadSheets()">üîÑ Refresh</button>
  </div>
  
  <div id="profileBox" style="background:white; border-radius:16px; box-shadow:0 2px 6px rgba(0,0,0,0.08); padding:16px; margin-bottom:16px;">
  
  <div><strong>Username:</strong> <span id="username">-</span></div>
  <div><strong>Location:</strong> <span id="location">-</span></div>
  <div><strong>Container ID:</strong> <span id="container">-</span></div>
  <div><strong>Status:</strong> <span id="status">-</span></div>
</div>

  <div id="buttonContainer" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-bottom:16px;">
    <button onclick="showModal('profileModal')">üìÑ Show Accounts</button>
    <button onclick="linkPost()">Link Post</button> <!-- showModal('postsModal') üìù Show Posts-->
    <button onclick="openThreadsMediaPicker()">üñä Pick Image</button>
    <button onclick="pickTodayPost()">üìÖ Pick Post</button> <!--; openThreadsPost()  pickRandom('Caption'); openThreadsPost()-->
    <button onclick="pickRandom('Reply'); openThreads()">üí¨ Pick Reply</button>
    <button onclick="pickRandom('Comments'); openThreads()">üí≠ Pick Comment</button>
</div>

<div style="font-size: 10px;">
  <button id="rotateIpBtn" onclick="rotateIP(50)">üîÑ</button>
  Current IP: |<span id="currentIP">fetching...</span>|
  Age: <span id="ipAge">0s</span>
  
  <div id="ipBar" class="loading">
    IP Status: Checking...
  </div>
</div>
    
  
  <div id="profileModal" class="modal">
    <div class="modal-content">
      <button onclick="hideModal('profileModal')" style="position:absolute; top:10px; left:10px; background:#ffdddd; border:none; border-radius:6px; padding:4px 10px;">‚ùå</button>
      <h3 style="margin-top:0;">üìÑ Accounts Sheet</h3>
      <table id="profileTable"></table>
    </div>
  </div>

  <div id="postsModal" class="modal">
    <div class="modal-content">
      <button onclick="hideModal('postsModal')" style="position:absolute; top:10px; left:10px; background:#ffdddd; border:none; border-radius:6px; padding:4px 10px;">‚ùå</button>
      <h3 style="margin-top:0;">üìù Posts Sheet</h3>
      <table id="postsTable"></table>
    </div>
  </div>

  <div id="toast"></div>
  <script>
    function runNextContainer() {
    window.location.href = "shortcuts://run-shortcut?name=Next%20container";
  }
    function GotoFirst() {
    window.location.href = "shortcuts://run-shortcut?name=first";
  }

    function linkPost() {
  try {
    showToast("Opening the link post...");
    // Clean version of the URL (without tracking parameters)
    window.open("https://www.threads.net/@piperallyglow/post/DSgboU8DEia");
    showToast("Link post opened!");
  } catch (e) {
    showToast("Error opening link post");
    console.error(e);
  }
}
    
      
    const sheetUrl = 'https://script.google.com/macros/s/AKfycbxl9YgraQ_0ZHX90hsHf3L9U8QHDOVRtfegquHj-yLbbmeVdyvur_dToRDrsm9ThF7sMw/exec';
    let profiles = [], currentProfile = 0;
    let sheetCache = {}, pickedPostIndexes = {};

async function fetchSheet(sheetName) {
  if (sheetCache[sheetName]) return sheetCache[sheetName];
  const res = await fetch(`${sheetUrl}?sheet=${sheetName}`);
  if (!res.ok) throw new Error("Failed to fetch " + sheetName);
  const data = await res.json();
  sheetCache[sheetName] = data;
  return data;
}

async function preloadSheets() {
  try {
    setButtonsDisabled(true); // Lock buttons
    showToast("Refreshing data...");

    sheetCache = {}; // clear old data
    const savedIndex = parseInt(localStorage.getItem('lastProfileIndex')) || 0;

    profiles = await fetchSheet('Accounts');
    sheetCache['Accounts'] = profiles;
    sheetCache['Posts'] = await fetchSheet('Posts');
    sheetCache['Reply'] = await fetchSheet('Reply');
    sheetCache['Comments'] = await fetchSheet('Comments');
    sheetCache['Caption'] = await fetchSheet('Caption');

    showToast("Sheets refreshed!");
    displayProfile(savedIndex);
  } catch (e) {
    showToast("Refresh failed");
  } finally {
    setButtonsDisabled(false); // Unlock buttons
  }
}


function displayProfile(index) {
  if (profiles.length === 0) return;
  currentProfile = (index + profiles.length) % profiles.length;
  localStorage.setItem('lastProfileIndex', currentProfile); // Save to localStorage

  const profile = profiles[currentProfile];
  const box = document.getElementById('profileBox');

  document.getElementById('username').textContent = profile.username;
  document.getElementById('location').textContent = profile.location;
  document.getElementById('container').textContent = profile.container;
  document.getElementById('status').textContent = profile.status || "-";

  // Set background color based on status
  const status = (profile.status || "").toLowerCase();
  if (status === "active") {
    box.style.background = "#d4fcd4"; // light green
  } else if (status === "suspended") {
    box.style.background = "#ffd4d4"; // light red
  } else {
    box.style.background = "white"; // default
  }
}

function nextProfile() { displayProfile(currentProfile + 1); }
function prevProfile() { displayProfile(currentProfile - 1); }
function goToFirstProfile() { displayProfile(0); }

function showModal(id) {
  if (id === 'profileModal') loadAccounts();
  if (id === 'postsModal') loadPosts();
  document.getElementById(id).style.display = 'flex';
}
function hideModal(id) {
  document.getElementById(id).style.display = 'none';
}

async function loadAccounts() {
  try {
    const accounts = await fetchSheet('Accounts');
    const table = document.getElementById("profileTable");
    table.innerHTML = '<tr><th>Username</th><th>Location</th><th>Container ID</th></tr>' +
      accounts.map(p => `<tr><td>${p.username}</td><td>${p.location}</td><td>${p.container}</td></tr>`).join('');
  } catch (e) {
    showToast("Failed to load accounts");
  }
}

async function loadPosts() {
  try {
    const posts = await fetchSheet('Posts');
    const table = document.getElementById("postsTable");
    const days = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];
    table.innerHTML = '<tr>' + days.map(d => `<th>${d}</th>`).join('') + '</tr>' +
      posts.map(row => `<tr>` + days.map(day => `<td>${row[day] || ''}</td>`).join('') + '</tr>').join('');
  } catch (e) {
    showToast("Failed to load posts");
  }
}

function pickRandom(sheetName) {
  showToast(`Copying from ${sheetName}...`);
  fetchSheet(sheetName).then(data => {
    const choice = data[Math.floor(Math.random() * data.length)];
    let value = Object.values(choice)[0];

    // Replace (loc) with the current profile's location
    const loc = profiles[currentProfile]?.Location || profiles[currentProfile]?.location || "";
    value = value.replace(/\(loc\)/gi, loc);

    navigator.clipboard.writeText(value);
    showToast(`${sheetName} copied!`);
  }).catch(() => showToast(`Failed to load ${sheetName}`));
}


function resetPickedPosts() {
  pickedPostIndexes = {};
  showToast("Post pool reset!");
}

//media attach shit
// Global variable to track used caption indexes (persists across calls)
let usedCaptionIndexes = [];

async function openThreadsMediaPicker() {
  const sheetName = 'Caption';

  try {
    showToast(`Picking from ${sheetName}...`);

    const data = await fetchSheet(sheetName);

    if (!data || data.length === 0) {
      showToast(`No captions found in ${sheetName}`);
      return;
    }

    // If we've used all captions, reset the pool
    if (usedCaptionIndexes.length >= data.length) {
      usedCaptionIndexes = [];
      showToast("All captions used, restarting pool");
    }

    // Find unused captions
    const unused = data
      .map((row, index) => ({ index, row }))
      .filter(item => !usedCaptionIndexes.includes(item.index));

    // This should never happen due to the reset above, but safety check
    if (unused.length === 0) {
      usedCaptionIndexes = [];
      unused = data.map((row, index) => ({ index, row }));
    }

    // Pick a random unused caption
    const selected = unused[Math.floor(Math.random() * unused.length)];
    usedCaptionIndexes.push(selected.index);

    // Get the caption text (assuming it's the first/only meaningful column)
    let value = Object.values(selected.row)[0];

    // Replace (loc) with current profile location
    const location = profiles[currentProfile]?.Location || profiles[currentProfile]?.location || "";
    value = value.replace(/\(loc\)/gi, location);

    // Copy to clipboard
    await navigator.clipboard.writeText(value);

    showToast("Caption copied!");

    // Open Threads compose window
    window.open("https://www.threads.net/intent/post");

  } catch (e) {
    showToast(`Failed to load ${sheetName}`);
    console.error(e);
  }
}

    
let lastPickedText = ""; //ito dagdag
async function pickTodayPost() {
  try {
    showToast("Picking today's post...");
    const posts = await fetchSheet('Posts');
    const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    const today = days[new Date().getDay()];

    const todayPosts = posts
      .map((row, index) => ({ index, text: row[today] }))
      .filter(p => p.text?.trim());

    if (!pickedPostIndexes[today]) pickedPostIndexes[today] = [];
    const unused = todayPosts.filter(p => !pickedPostIndexes[today].includes(p.index));

    if (unused.length === 0) {
      pickedPostIndexes[today] = [];
      showToast("All posts used, restarting pool");
      return pickTodayPost();
    }

    const selected = unused[Math.floor(Math.random() * unused.length)];
    pickedPostIndexes[today].push(selected.index);

    const location = profiles[currentProfile]?.location || profiles[currentProfile]?.Location || "";
    const finalText = selected.text.replace(/\(loc\)/gi, location);

    /*await navigator.clipboard.writeText(finalText);
    showToast("Post copied with location!");*/
    lastPickedText = finalText;
    const encoded = encodeURIComponent(finalText);
    window.open(`https://www.threads.net/intent/post?text=${encoded}`, "_blank");
    showToast("Opening Threads‚Ä¶");
  } catch (e) {
    showToast("Error picking post");
  }
}

function showToast(message) {
  const toast = document.getElementById("toast");
  toast.textContent = message;
  toast.className = "show";
  setTimeout(() => { toast.className = toast.className.replace("show", ""); }, 2500);
}

function searchLocation() {
    const location = profiles[currentProfile]?.Location || profiles[currentProfile]?.location || '';
    if (!location) {
      showToast("Location not found for this profile.");
      return;
    }

    const query = encodeURIComponent(location);
    const url = `https://www.threads.net/search?q=${query}`;
    window.open(url, '_blank');
  }
    function openThreads() {
   window.open(`https://threads.com/`, "_blank");
}

    function openThreadsPost() {
   window.open("https://www.threads.net/intent/post");
}
    
    function setButtonsDisabled(disabled) {
  const buttons = document.querySelectorAll('#buttonContainer button');
  buttons.forEach(btn => btn.disabled = disabled);
}
    
// === NEW IP ROTATION CODE ===
    let currentIP = null;
    let ipStartTime = null;
    const rotateUrl = "https://i.fxdx.in/actionlinks/do/changeip/YTbojipTQnuowNvn2MkNoA";

    async function fetchIP() {
      try {
        const res = await fetch("https://api.ipify.org?format=json");
        const data = await res.json();
        return data.ip;
      } catch (e) {
        return null;
      }
    }

async function updateIPDisplay() {
  const ipSpan = document.getElementById("currentIP");
  const ageSpan = document.getElementById("ipAge");
  const bar = document.getElementById("ipBar");
  
  // Start with loading state
  bar.className = "loading";
  ipSpan.textContent = "checking...";
  ageSpan.textContent = "-";

  const newIP = await fetchIP();
  
  if (!newIP) {
    // Failed to fetch IP
    ipSpan.textContent = "error";
    ageSpan.textContent = "-";
    bar.className = "error";
    currentIP = null;
    ipStartTime = null;
    return;
  }

  const ipChanged = (newIP !== currentIP);
  
  if (ipChanged || currentIP === null) {
    // IP is new (either changed or first time)
    currentIP = newIP;
    ipStartTime = Date.now();
    bar.className = "success";  // ‚Üê Turn green on fresh IP
  } else {
    // Same IP as before ‚Üí neutral gray
    bar.className = "loading";
  }

  ipSpan.textContent = currentIP;

  // Age updater (clears old interval if exists)
  if (window.ipAgeInterval) clearInterval(window.ipAgeInterval);
  
  const updateAge = () => {
    if (!ipStartTime) {
      ageSpan.textContent = "-";
      return;
    }
    const seconds = Math.floor((Date.now() - ipStartTime) / 1000);
    let text = "";
    if (seconds < 60) text = seconds + "s";
    else if (seconds < 3600) text = Math.floor(seconds / 60) + "m";
    else text = Math.floor(seconds / 3600) + "h";
    ageSpan.textContent = text;
  };
  
  updateAge();
  window.ipAgeInterval = setInterval(updateAge, 1000);
}

async function rotateIP(maxAttempts = 50) {
  const btn = document.getElementById("rotateIpBtn");
  const bar = document.getElementById("ipBar");

  // Disable button and set initial rotating state
  btn.disabled = true;
  bar.className = "loading";
  bar.textContent = "Rotating IP... Please wait";

  showToast("Starting IP rotation...");

  let attempts = 0;
  let oldIP = currentIP;

  // Ensure we have the current IP before starting
  if (!oldIP) {
    await updateIPDisplay();
    oldIP = currentIP;
  }

  // Show old IP in bar for reference
  bar.textContent = `Rotating... Current: ${oldIP || 'unknown'}`;

  while (attempts < maxAttempts) {
    attempts++;
    showToast(`Rotating IP... (attempt ${attempts}/${maxAttempts})`);

    try {
      // Trigger the IP rotation
      await fetch(rotateUrl, { method: "GET", mode: "no-cors" });

      // Wait for the proxy to apply the new IP
      await new Promise(r => setTimeout(r, 2500));

      // Update the displayed IP
      await updateIPDisplay();

      // Check if IP actually changed
      if (currentIP && currentIP !== oldIP) {
        // SUCCESS!
        bar.className = "success";
        bar.textContent = `‚úì IP Changed Successfully ‚Üí ${currentIP}`;
        
        showToast(`IP successfully changed to ${currentIP}`);
        btn.disabled = false;
        return; // Done!
      }

      // IP didn't change yet ‚Äî update bar and continue
      bar.className = "loading";
      bar.textContent = `No change yet (still ${currentIP || 'unknown'}) ‚Äî retrying... (${attempts}/${maxAttempts})`;

      // Small delay before next attempt
      await new Promise(r => setTimeout(r, 1000));

    } catch (e) {
      console.error("Rotation attempt failed:", e);
      bar.className = "error";
      bar.textContent = `Error on attempt ${attempts} ‚Äî retrying...`;
      
      // Wait a bit longer on error
      await new Promise(r => setTimeout(r, 2000));
    }
  }

  // If we get here: max attempts reached without success
  bar.className = "error";
  bar.textContent = `‚úó Failed: IP did not change after ${maxAttempts} attempts (still ${currentIP || 'unknown'})`;
  
  showToast("IP rotation failed after maximum attempts");
  btn.disabled = false;
}

// Auto-refresh IP on load and every 30 seconds (optional)
    window.onload = () => {
      preloadSheets();
      updateIPDisplay();
      setInterval(updateIPDisplay, 30000); // keep IP display fresh
    };
  </script>
</body>
</html>
